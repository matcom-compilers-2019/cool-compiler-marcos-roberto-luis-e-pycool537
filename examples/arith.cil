.TYPES

type A {
    attribute var;
    method A_init_A: A
    method A_value : Int;
    method A_set_var : A;
    method A_method1 : A;
    method A_method2 : B;
    method A_method3 : C;
    method A_method4 : D;
    method A_method5 : E;
}

type B {
    attribute var;
    method value : Int;
    method set_var : A;
    method method1 : A;
    method method2 : B;
    method method3 : C;
    method method4 : D;
    # Hasta aquí no hay bateos con la herencia pero...
    method method5 : E;
    # Este se redefine, entonces:
    # - Qué nombre le pongo de manera que pueda escribir el function?
}

type C {
    attribute var;
    method value : Int;
    method set_var : A;
    method method1 : A;
    method method2 : B;
    method method3 : C;
    method method4 : D;
    # También redefine el method5
    method method5 : E;
    method method6 : A;
}

type D {
    attribute var;
    method value : Int;
    method set_var : A;
    method method1 : A;
    method method2 : B;
    method method3 : C;
    method method4 : D;
    method method5 : E;
    method method7 : Bool;
}

type E {
    attribute var;
    method value : Int;
    method set_var : A;
    method method1 : A;
    method method2 : B;
    method method3 : C;
    method method4 : D;
    method method5 : E;
    # En este caso hay que tener mucho cuidado...
    # Porque el method6 no se hereda, sino que se implementa como nuevo
    # Sin embargo, al tenerlo, para MIPS se verá como que E hereda de C
    # En vez de solo heredar de D
    method method6 : A;
    method method7 : Bool;
}

.CODE
function init_A {
    ARG a;
    LOCAL new_a;
    new_a = ALLOCATE A;
    SETATTR new_a var 0;
    RETURN new_a;
}

-- Esto es pa probar
class A{
	var: Int;

	value(): Int{
		var <- 3 + (4/2);
	}
}

class B {
	atributo: A;
	metodo(): Int{
		atributo.var = 5;
	}
}
-- Se acabo la prueba

function value {
    ARG a;
    LOCAL x;
    x = GETATTR a var;
    RETURN x;
}

function set_var {
    ARG a;
    ARG num;
    SETATTR a var num;
    RETURN a;
}

# Same
function method1 {
    ARG a;
    ARG num;
    RETURN a;
}

# Plus
function method2 {
    ARG a;
    ARG num1;
    ARG num2;
    LOCAL x;
    LOCAL b;
    LOCAL y;
    x = num1 + num2;
    b = ALLOCATE B;
    y = VCALL B init_b;
    RETURN y;
}

# Negate
function method3 {
    ARG a;
    ARG num;
    LOCAL x;
    LOCAL c;
    LOCAL y;
    x = 0;
    PARAM num;
    x = CALL negation;
    c = ALLOCATE C;
    y = VCALL C init_c
    PARAM a;
    PARAM x;
    c = VCALL A set_var
    RETURN y;
}

# diff
function method4_if0_block0 {
    ARG if_0_x1;
    ARG if_0_d1;
    ARG num1;
    ARG num2;

    LOCAL result;
    
    if_0_x1 = 0;
    if_0_x1 = num1 - num2;
    if_0_d1 = ALLOCATE D;
    
    PARAM if_0_d1;
    result = VCALL D set_var;
    
    RETURN result;
}

function method4_if0_block1 {
    ARG if_0_x0;
    ARG if_0_d0;
    ARG num1;
    ARG num2;

    LOCAL result;

    if_0_x0 = 0;
    if_0_x0 = num2 - num1;
    if_0_d0 = ALLOCATE D;
    
    PARAM if_0_d0;
    result = VCALL D set_var;
    
    RETURN result;
}

function method4 {
    ARG a;
    ARG num1;
    ARG num2;
    LOCAL if_0_aux0;
    LOCAL if_0_x0;
    LOCAL if_0_x1;
    LOCAL if_0_d0;
    LOCAL if_0_d1;
    LOCAL ret_val;
    if_0 = num2 < num1;

    # Aquí va el if hecho con GOTO
    IF if_0 GOTO if_0;
    # El cuerpo del else
    PARAM num2;
    PARAM num1;
    PARAM if_0_d1;
    PARAM if_0_x1;
    ret_val = CALL method4_if0_block1
    # TODO... Continue here!!!
    GOTO FI_0;
    
    IF_0:
    # El cuerpo del then
    ret_val = CALL method4_if0_block0
    
    FI_0:
    RETURN ret_val
}

# factorial
function method5_block0_block0 {
    ARG y;
    ARG x;
    x = x * y;
    y = y + 1;
    RETURN y;
}

function method5_block0 {
    ARG x;
    ARG num;
    LOCAL y;
    LOCAL ret_val;
    LOCAL method5_block0_e;
    y = 1;
    loop_label0:
    IF y <= num GOTO while_label0
    GOTO pool_label0
    
    while_label0:
    PARAM x;
    PARAM y;
    ret_val = CALL method5_block0_block0;
    GOTO loop_label0;
    
    pool_label0:
    method5_block0_e = ALLOCATE E;
    PARAM method5_block0_e;
    PARAM x;
    ret_val = VCALL E set_var
    RETURN ret_val;
}

function method5 {
    ARG num;
    LOCAL x;
    x = 1;
    PARAM num;
    PARAM x;
    ret_val = CALL method5_block0
    RETURN ret_val;
}

...
# un ejemplo de case
function class_type {
    ARG var;
    
}
